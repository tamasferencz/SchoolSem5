# üÜò Konkurens Programoz√°s Vizsga

## Tartalom

1. K√∂telez≈ë importok
2. Deklar√°ci√≥k (Interface ‚Üí Konkr√©t oszt√°ly)
3. Legfontosabb met√≥dusok
4. K√≥dmint√°k
5. Buktat√≥k

---

## 1. K√∂telez≈ë importok

```java
import java.util.concurrent.*;
import java.util.concurrent.atomic.*;
import java.util.*;
```

---

## 2. Deklar√°ci√≥k

P√©ld√°k:

- ExecutorService ‚Äî Executors.newFixedThreadPool(n)
- BlockingQueue ‚Äî ArrayBlockingQueue
- ConcurrentMap ‚Äî ConcurrentHashMap
- AtomicInteger ‚Äî AtomicInteger

P√©lda: fix sz√°m√∫ sz√°l (pl. 10 db)

```java
// Fix sz√°m√∫ sz√°l (pl. 10 db)
ExecutorService executor = Executors.newFixedThreadPool(10);
BlockingQueue<String> queue = new ArrayBlockingQueue<>(10);
Map<String, Integer> map = new ConcurrentHashMap<>();
AtomicInteger counter = new AtomicInteger(0);
```

---

## 3. Legfontosabb met√≥dusok

### ExecutorService

- `executor.execute(() -> { ... })` ‚Äî feladat ind√≠t√°sa (Runnable), nem ad vissza √©rt√©ket.
- `executor.submit(() -> { ... })` ‚Äî feladat ind√≠t√°sa, visszaad egy `Future`-t.
- `executor.shutdown()` ‚Äî norm√°l le√°ll√≠t√°s (v√°rja a fut√≥ feladatokat).
- `executor.shutdownNow()` ‚Äî azonnali le√°ll√≠t√°s (megpr√≥b√°lja megszak√≠tani a fut√≥ feladatokat).

### BlockingQueue (A 3 viselked√©si m√≥d)

- Blokkol√≥s (standard):
  - `put(e)` ‚Äî betesz, ha tele van: v√°r.
  - `take()` ‚Äî kivesz, ha √ºres: v√°r.
- Id≈ëz√≠t≈ës:
  - `offer(e, 100, TimeUnit.MILLISECONDS)` ‚Äî pr√≥b√°l betenni 100ms-ig.
  - `poll(100, TimeUnit.MILLISECONDS)` ‚Äî pr√≥b√°l kivenni 100ms-ig.
- Azonnali (kiv√©teles):
  - `add(e)` ‚Äî ha tele van: `IllegalStateException`.
  - `remove(e)` ‚Äî kivesz egy konkr√©t elemet (true/false).
  - `peek()` ‚Äî r√°n√©z√©s a fejre, nem veszi ki (ha √ºres: `null`).

### ConcurrentHashMap / Concurrent collections

- `putIfAbsent(key, val)` ‚Äî csak akkor teszi be, ha a kulcs m√©g nincs ott.
- `computeIfPresent(key, (k, v) -> v - 1)` ‚Äî atomikus m√≥dos√≠t√°s.

### AtomicInteger

- Sz√°lbiztos sz√°ml√°l√≥ (helyettes√≠ti a `++`-t t√∂bb sz√°ln√°l).

```java
AtomicInteger counter = new AtomicInteger(0);
counter.incrementAndGet(); //noveles
counter.decrementAndGet(); //csokkentes
```

### Szal Letrehozas/Inditas

```java
private FoodProducer producer;
private Thread producerThread;
producer = new FoodProducer(this);
producerThread = new Thread(producer);
producerThread.start();
```

---

## 4. K√≥dmint√°k

A) Executor + Queue (Modern megold√°s ‚Äî aj√°nlott)

```java
// Deklar√°ci√≥k
BlockingQueue<String> queue = new ArrayBlockingQueue<>(5);
ExecutorService executor = Executors.newFixedThreadPool(2);

// Fogyaszt√≥
executor.execute(() -> {
    try {
        while (true) {
            String item = queue.take(); // blokkol, ha √ºres
            System.out.println("Feldolgozva: " + item);
            Thread.sleep(ThreadLocalRandom.current().nextInt(100, 500));
        }
    } catch (InterruptedException e) {
        Thread.currentThread().interrupt(); // helyes megszak√≠t√°s-kezel√©s
    }
});
```

B) Wait / Notify (Low-level megold√°s)

```java
Object lock = new Object();
boolean ready = false;

// V√°rakoz√≥ sz√°l
synchronized (lock) {
    while (!ready) {
        try {
            lock.wait(); // elengedi a lockot
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
    System.out.println("Mehet!");
}

// Jelz≈ë sz√°l
synchronized (lock) {
    ready = true;
    lock.notifyAll();
}
```

C) V√©letlenszer≈± v√°rakoz√°s (Sleep)

```java
try {
    Thread.sleep(ThreadLocalRandom.current().nextInt(100, 500));
} catch (InterruptedException e) {
    Thread.currentThread().interrupt();
}
```

---

## 5. Buktat√≥k

- Mindig legyen `try-catch` az olyan h√≠v√°sok k√∂r√ºl, mint `sleep`, `wait`, `take`, `put` (InterruptedException).
- Generikusok: haszn√°lj `List<String>`/`Map<K,V>` jel√∂l√©st ‚Äî ne hagyd le a tipusparam√©tert.
- `wait()` vs `sleep()`:
  - `wait()` elengedi a lockot (csak `synchronized`-ban h√≠vhat√≥).
  - `sleep()` nem engedi el a lockot.
- Interface vs Class:
  - Helyes: `Map<String, Integer> m = new ConcurrentHashMap<>();`
  - A polimorfizmus haszn√°lata fontos.
- Ne felejtsd el le√°ll√≠tani az `Executor`-t (`executor.shutdown()`), k√ºl√∂nben a program nem √°ll le.

---
